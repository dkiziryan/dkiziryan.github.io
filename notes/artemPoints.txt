
1. Promises can be done a lot simpler by just using $http without $q. https://docs.angularjs.org/api/ng/service/$http . The $http object has a then() method, which is a promise. So in getNflGameInfo() you can return $http(…); and the usage in the nflAppController should work the same.

2. Why separate the service into a separate module? It may make sense in a big application, with a set of services isolated. Seemed like overkill not to have it as part of the same nfl_app module.

3. Put constants into angular “constants” (var url = "http://www.nfl.com/liveupdate/scorestrip/ss.xml”; and internal )
done

4. Instead of {{ }} for template displaying of dynamic data, use ng-bind. If there’s more than one item in the parent element, create a span, <span ng-bind=“game._v”></span>. You can read about it in more detail. As I understand when you have {{}} angular rescans the entire template for changes / updates. While with ng-bind, it’s a direct update to the bound spot.
done

5. Create a separate factory for your data (gameInfoList) - say gameInfoModel (I call these type of factories models). The factor should have an attribute for gameInfoList as well as the methods that set it - say loadGameInfoList - (isError and whatever else should be an attribute too). Inject the factor into the controller. 

So in the controller, you first assign $scope.gameInfoList = gameInfoModel.list;. This binds the scope to the data from the factory. Then you call gameInfoModel.loadList() instead of your line 10 of controller (where you load the data) and same gameInfoModel.loadList() inside the interval. This way you have one place where the loading takes place, instead of code duplication. In your loadList()’s resolving promise, you’ll need to do $rootScope.$apply(…set the list…); in order for a digest to be triggered to propagate the new data to the controller and then UI.

6. what’s pageError vs isError?

7. read about properly injecting dependencies for minification https://scotch.io/tutorials/declaring-angularjs-modules-for-minification. Always to it this way, no matter what the project is - good habit and saves TONS of production debugging.